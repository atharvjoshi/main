= Incident Management System - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103-T11-1/main
:websiteURL: https://ay1920s1-cs2103-t11-1.github.io

By: `Team CS2103-T11-1`      Since: `October 2019`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `IncidentManagerParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Incident Manager data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Incident Manager`, which `Person` can reference. This would allow `Incident Manager` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Person]]
==== Person Model component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Person.java[`Person.java`]

The `Person`,

* represents a user account on the incident manager.
* Contains the account `Username`, `Password`, `Name`, `Phone`, `Email`

[[Design-Incident]]
==== Incident component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Incident.java[`Incident.java`]

The `Incident`,

...

[[Design-Vehicle]]
==== Incident component

*API* : link:{repoURL}/src/main/java/seedu/address/model/Vehicle.java[`Vehicle.java`]

The `Vehicle`,

* represents a vehicle that can be dispatched to incident sites.
* Contains the attributes `VehicleNumber`, `VehicleType`, `district` and `availability`.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Incident Manager data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.incidentManager.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::accessControl[]
=== Access Control feature
==== Implementation

The access control feature is centered around three core concepts:

1. Command Restrictions: Restriction of access to commands until after identity is verified
2. Identity Verification: Verification of identity via unique credentials and a confidential key
3. Account Management Restrictions: Access level restrictions for commands affecting other accounts

===== Command Restrictions

Prior to login, the user is only granted access to the `Login`, `Add`, and `Exit` commands. This is achieved via a guard statement in the `LogicManager` checking whether the user is logged in or the command created is an approved command that doesn't require login.

[NOTE]
The guard statement throws a command exception if the following conditions are met: +
`!model.isLoggedIn() && !(command instanceof LoginCommand || command instanceof AddCommand || command instanceof ExitCommand)`

Activity Diagram for illustration:

image::AccessActivityDiagram.png[]

===== Identity Verification

Users are required to login via the `Login` command with a `Username` and `Password`. See user guide for more details on the command syntax for `Login`. Users are also allowed to `Logout` and thus end their `Session`.

[NOTE]
Session details are displayed on the status bar in the GUI to reflect whether a user is logged in, and the username as well as time logged in if a user is logged in.

Uniqueness of username is ensured by preventing duplicates during the account creation [`AddCommand`] and account update [`UpdateCommand`] processes. The respective commands will check the list of accounts in the model and throw an exception if a duplicate is found.

===== Account Management Restrictions

To prevent abuse (e.g. adding a dummy account and editing/deleting other accounts), all new accounts are differentiated from `Admin` accounts. This restriction based on access level is implemented via account `Tags`:

* Only a `Person` with an admin `Tag` can access account management features. Such a person will henceforth be referred to as an Admin.
* Users who are not admins are not allowed to add tags (via both AddCommand and UpdateCommand).
* Only Admins are allowed to edit or add tags (via both AddCommand and UpdateCommand).

[NOTE]
Non-admins can still edit their own account details via the `Update` command. Refer to user guide for more info.

The checks described above all function in the command execution stage. The `Add` command, `Update` command, and `Delete` retrieve the `LoggedInPerson` from the `Model` via utilisation of the `Session` object.

Sequence Diagram for illustration:

image::AccessSequenceDiagram.png[]

==== Design Considerations

===== Aspect: How Command Restrictions are Managed

* **Alternative 1 (current choice):** Guard statement in LogicManager prior to Command Execution.
** Pros: Single control point, easy to maintain and debug.
** Cons: Command still gets instantiated, memory allocated to command creation.
* **Alternative 2:** Guard statement in IncidentManagerParser
** Pros: Early catching of restriction, command doesn't get instantiated unnecessarily.
** Cons: Need to expose model to parser, increasing coupling.

===== Aspect: How Identity Verification is Managed

* **Alternative 1 (current choice):** Unique username and password.
** Pros: Easy to implement.
** Cons: Sufficiently advanced users can access the data file directly to retrieve user passwords.
* **Alternative 2:** Physical security USB dongle.
** Pros: Secure individually identifiable apparatus.
** Cons: Prone to loss and potential duplication.

===== Aspect: How Account Management Restrictions are Managed

* **Alternative 1 (current choice):** Utilisation of Account Tags
** Pros: Easy to implement.
** Cons: Users cannot add tags to themselves.
* **Alternative 2:** Addition of an Admin account attribute.
** Pros: Distinct object class, improves cohesiveness.
** Cons: Hard to implement.
// end::accessControl[]

// tag::accountManagement[]
=== Account Management feature
==== Implementation

The account management feature functions as a suite of commands available to the user. The commands available as part of this suite:

* Add Command - Creates a new user account.
* Update Command - Edits a user account. Not including an index updates your own account.
* Delete Command - Deletes a a user account. Not allowed to delete your own account.
* List Command - Lists all user accounts or those whose tags match the user input.
* Find Command - Searches for user accounts based on matching name keywords.
* Swap Command - Swaps GUI interface between account management and incident management.

[NOTE]
Only `Admin` accounts can access the full suite of account management features. See access control feature for more information. Non-Admins only have access to `Add`, `List`, `Find`, and `Swap` commands, as well as `Update` for their own account.

In the code base, Persons represent user accounts. See person model for more information.

==== Design Considerations
===== Aspect: How Update executes

* **Alternative 1 (current choice):** No index indicates own account update
** Pros: Improves user experience.
** Cons: Prone to user error.
* **Alternative 2:** Select index of own account for update
** Pros: Easy to implement.
** Cons: Decreases user experience.

===== Aspect: How Tag searching executes

* **Alternative 1 (current choice):** Adding keyword after the List command prefix performs a search
** Pros: Intuitive. Improves user exprience.
** Cons: Can only search for one tag at a time.
* **Alternative 2:** Utilising Find command to search for tags
** Pros: Potential to include more granular filters.
** Cons: Decreases user experience.
// end::accountManagement[]

// tag::incidentdraftcreation[]
=== Incident Draft Creation feature
==== Proposed Implementation

The incident draft creation mechanism is facilitated by the New Command. It creates a new draft incident report based on district of incident, optional automatic vehicle dispatchment.

==== Design Considerations

===== Aspect: How incident draft creation executes

* **Alternative 1 (current choice):** Auto assignment of vehicles
** Pros: Reduces number of steps of execution.
** Cons: User does not get to choose.
* **Alternative 2:** Manual assignment of vehicles
** Pros: User is able to choose vehicle to dispatch.
** Cons: More number of steps.
// end::incidentdraftcreation[]

// tag::incidentfill[]
=== [Proposed] Incident Filling and Submission feature
==== Proposed Implementation
The incident filling and submission subroutines are facilitated by the `fill` and `submit` commands respectively. In the IMS, each incident can have one of three statuses - `DRAFT`, `COMPLETE`, and `FINAL`. The `fill` command facilitates a `DRAFT` incident report becoming a `COMPLETE` incident report while the `submit` command facilitates a `COMPLETE` incident report becoming a `FINAL` incident report.

===== Overview of `Fill` and `Submit`

Each command works in two modes:

1. Without parameters:
In this mode, the command - `fill` or `submit` - lists the incidents that are ready for Filling (i.e. only all `DRAFTS` incidents) or Submitting (i.e. only all `COMPLETE` incidents).
2. With parameters:
In this mode, the command - `fill` or `submit` - actually fills (i.e. changes incident status from `DRAFT` -> `COMPLETE`) or submits (i.e. changes incident status from `COMPLETE` -> `FINAL`) the specified incident.
These two commands as well as the two modes they can be used in are summarised in the activity diagrams below:

Fill Command
image::fillCommandActivityDiagram.png[]

Submit Command
image::submitCommandActivityDiagram.png[]

===== No parameter mode (listing incidents)
The `IncidentManagerParser` will return a new `FillCommand` which has its fields `targetIndex`, `callerNumber`, and `description` initialised to null (as they won't be required). The `execute()` method in `FillCommand` checks for these null conditions and simply displays the list of incidents filtered according to whether they are `DRAFT` or not.
TODO - SEQUENCE DIAGRAM FOR FILL COMMAND WITHOUT PARAMETERS
The `SubmitCommand` functions similarly, this time listing the incidents filtered by whether they are `COMPLETE` or not.
===== Parameter mode (modifying incidents)
The `FillCommandParser` will be invoked to parse the fields `targetIndex`, `callerNumber`, and `description` and return a `FillCommand` containing these non-null fields. The `execute()` method in `FillCommand` will now fetch the specified incident from the list of drafts and call the static `updateReport()` method. The `updateReport()` method creates a new Incident object which has all its required attributes filled. The attributes from the incident to be updated are simply copied into this new Incident object. The fill command then inserts this new Incident into the list of incidents at the same index.
The `SubmitCommand` functions similarly, with one crucial difference. As no Incident fields are to be updated, the specified incident is simply retrieved, marked as `FINAL` using the static `submitReport()` method, and inserted into the list of incidents at the same index again. The `submitReport` method also creates a new Incident object which is a copy of the Incident to be submitted, with the difference being that the newly created Incident is marked `FINAL`.
TODO - SEQUENCE DIAGRAM FOR FILL COMMAND WITH PARAMETERS

==== Design Considerations

===== Aspect: How incident fill executes

* **Alternative 1 (current choice):** ...
** Pros: ...
** Cons: ...
* **Alternative 2:** ...
** Pros: ...
** Cons: ...
// end::incidentfill[]

// tag::incidentsearch[]
=== Incident Search feature
==== Implementation

The incident search mechanism features a set of different types of searches that a user could utilise. Further documentation on the commands available in this set can be found within the link:{websiteURL}/main/UserGuide.html. The types of searches are as listed:
* Unfiltered - Displays all incidents in `Model`
* ID - Displays all incidents with exact matches in `IncidentId incidentId` in `Incident incident`
* Description - Displays all incidents with keyword(s) contained within the `Description description` in `Incident incident`
* Operator - Displays all incidents with keyword(s) contained within the name of the `Person operator` in `Incident incident`

The incident search mechanism is facilitated by `ModelManager`, which implements abstract class `Model`. It contains a `FilteredList<Incidents> filteredIncidents`, which internally stores the list of displayed incidents in the GUI. Additionally, it implements the following key method:
* `updateFilteredIncidentsList(Predicate<Incident> predicate)` - Updates the stored filtered incidents list with the new predicate

There are two possible commands within this set of searches. Firstly, we will consider when the user calls the command `incidents` in the application.

The following sequence diagram shows how the `incidents` command works:

image::ListIncidentsSequenceDiagram.png[]

As indicated in the diagram, the `LogicManager` instantiates a `ListIncidentsCommand` upon running command `execute(incidents)`. It then calls `ListIncidentsCommand#execute()`, which runs `Model#updateFilteredIncidentList` with the predicate `PREDICATE_SHOW_ALL_INCIDENTS`. This `Predicate<Incident>` always evaluates to true. This `Predicate<Incident>` is passed to `FilteredList<Incident> filteredList`, as a parameter to run the method `setPredicate()`. This updates the list of visible incidents. `CommandResult commandResult` is also returned to the `LogicManager` to log the success/failure of the method.

Next, we will look at an example in which the user calls `search` to look for incidents written by an operator whose name contains `Alex`.

The execution of this method is a little more complex.

The following sequence diagram shows how the `search` command identifies the keyword and flag, and returns related incidents:

image::SearchIncidentsSequenceDiagram.png[]

The key difference is the utility of the `SearchIncidentsCommandParser` to parse the keyword after tag `op\` in the command. It creates a `NameKeywordsPredicate` using the String "Alex", which is returned to be used in constructing a new instance of `SearchIncidentsCommand`, stored as a `Predicate<Incident> predicate`. From there, the process is similar, in that `SearchIncidentsCommand#execute()` is run, causing the Model to run `Model#updateFilteredIncidentList(predicate)` using the predicate stored in `SearchIncidentsCommand`. Upon updating the list similar to the `incidents` listing command above, `SearchIncidentsCommand` also calls `Model#getFilteredIncidentList()` to return `ObservableList<Incident>`. It obtains the size of this list, and returns it in `CommandResult commandResult`.

==== Design Considerations

===== Aspect: How incident search keyword is inputted

* **Alternative 1 (current choice):** Parse user input after flag (eg. `op\` or `desc\`)
** Pros: Easy to implement.
** Cons: Have to parse keyword from command and flag, user has to follow style of flag for successful search.
* **Alternative 2:** Prompt user for search input
** Pros: Separates command from keyword for ease of reading and parsing.
** Cons: Difficult to implement multi-command execution.

===== Aspect: How listing all incidents is called

* **Alternative 1 (current choice):** Utilise separate command `incidents`
** Pros: Intuitive to use.
** Cons: Similar code under different command.
* **Alternative 2:** Utilise `search` command (eg. `search unfiltered`)
** Pros: Less overlap in code.
** Cons: Unintuitive to the user as no search is being made, even more keywords to remember.

===== Aspect: How predicate is added to `SearchIncidentsCommand`

* **Alternative 1 (current choice):** `SearchIncidentsCommandParser` class calls `Model` to create a new Predicate based on search string.
** Pros: Abstracts the creation and management of predicates to the `Model`.
** Cons: Requires greater level of coupling between classes.
* **Alternative 2:** `SearchIncidentsCommand` or `SearchIncidentsCommandParser` directly create Predicate based on search string.
** Pros: Less dependencies within the parser class.
** Cons: Breaks abstraction flow.
// end::incidentsearch[]

// tag::incidentedit[]
=== Incident Edit feature
==== Proposed Implementation

The incident edit mechanism is facilitated by `EditCommand` class. Validity of user input is checked when `execute()` is called and an exception is thrown if invalid.

An exception will be thrown under these 2 conditions:
* `index.getZeroBased() >= listOfIncidents.size()`
* `!incidentToEdit.equals(editedIncident) && model.hasIncident(editedIncident)`

Below is an activity diagram to illustrate the process that the user may go through

image::EditCommandActivity.png[]

To prevent direct access and modification to the attributes in an incident object, a new incident object is created
using `EditIncident` each time the command is executed and then replaced at the specified index in a
`List<Incident>` that is facilitated by `FilteredIncidentList` class. This is all done in the execution stage.

Below is a sequence diagram to illustrate how the command executes:

image::EditCommandSequence.png[]

==== Design Considerations

===== Aspect: How incident edit executes

* **Alternative 1 (current choice):** Create a new incident object and replace the old copy in the list
** Pros: able to control access to attributes in incident objects
** Cons: more tedious implementation and more objects created
* **Alternative 2:** Directly access the attributes of the incident and change it
** Pros: less objects created, do not need to worry much about `IncidentId` of instance.
** Cons: More prone to errors since attributes can be directly access and changed outside the class.
// end::incidentedit[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*: Emergency Services Call Operator

* needs to quickly dispatch emergency vehicles
* has a need to manage a significant number of incidents
* prefer desktop apps over other types
* can type fast, prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage incidents and vehicle dispatch faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |operator |log into the system with a password |secure the system against unauthorised access

|`* * *` |operator |log into the system with a unique identifier |hold accountable others who use the system

|`* * *` |new user |create an account |log into the system to manage incidents

|`* * *` |operator |open the app |I can dispatch personnel and record an incident

|`* * *` |operator |view available vehicles |I can dispatch vehicles

|`* * *` |confused operator	|automatically prevent sending of non available vehicles |I won't be allowed to send occupied vehicles

|`* * *` |operator |to select a vehicle	|it would be dispatched

|`* * *` |operator |to contact the dispatched vehicle and confirm it has been selected |it would be dispatched

|`* * *` |operator |an ID to be generated for my summaries |my reports can be tagged for easy search

|`* * *` |operator |to have prompts for fields |I know the information required

|`* * *` |careless operator	|edit the report |I won't have to retype everything

|`* * *` |operator on shift	|to save the case for future retrieval |So that others can reference it locally

|`* *` |operator handling many cases |to quickly find relevant parties |I can submit the incident log

|`* *` |regular operator |to view the phone number |I can contact the caller whenever necessary

|`* *` |regular operator |to view the address |I can dispatch personnel based on proximity to address

|`* *` |operator who likes visual cues |to view the vehicles on patrol on a map |I have a visual on who to dispatch

|`* *` |As an operator |to view the available vehicles in descending order of proximity to site |the vehicle can reach the incident site asap

|`* *` |As an overwhelmed operator |to filter the available vehicles |I won't get confused over which vehicle to send

|`* *` |As a tired operator |warning prompt when I select the least optimal available vehicle |I minimise fatigue errors

|`* *` |As a busy operator |automatic spell and grammar check |so that I can type fast without worry

|`* *` |As an operator |keyboard shortcuts |I can type while I talk

|`* *` |As an operator working under supervisors |to alert the relevant parties |So that they can act on it

|`*` |advanced operator |to auto-transcribe the call |I can store the call transcript for record-keeping purposes

|`*` |operator |automatic triangulation of the call location |I can dispatch a vehicle even if the caller does not know his/her address

|`*` |as an anxious operator |nearby vehicles to be notified of the incident even though they're not dispatched |In case backup is needed

|`*` |As an operator that has to take many calls |to select from drop down lists for certain fields  |so that I can fill in the summary report fast

|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `IMS` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: User Login

*MSS*

1.  User inputs username and password
2.  IMS checks username & password
3.  IMS provides user with access
+
Use case ends.

*Extensions*

[none]
* 2a. The username is not found or password is incorrect.
+
[none]
** 2a1. IMS shows a generic error message to deter malicious intent.
Use case ends.

[discrete]
=== Use case: New incident

*MSS*

1.  User requests to create a new incident
2.  IMS prompts for confirmation of vehicle assignment
3.  User accepts auto assigned vehicle for dispatch
4.  IMS creates a new incident with autofill details
5.  IMS prompts for completion of incident report
6.  User fills in necessary details
7.  User submits incident report
+
Use case ends.

*Extensions*

[none]
* 3a. User opts for manual assignment.
+
[none]
** 3a1. IMS displays list of all available vehicles.
** 3a2. User selects index of vehicle to dispatch.
+
Use case resumes at step 4.

[none]
* 6a. User opts to complete report later.
+
[none]
** 6a1. IMS stores incident as a draft.
+
Use case ends.

[discrete]
=== Use case: Edit Incident

*MSS*

1.  User searches for an incident
2.  IMS retrieves the incident
3.  User edits the incident details
4.  IMS saves the edited incident report
+
Use case ends.

*Extensions*

[none]
* 2a. The incident is not found.
+
[none]
** 2a1. IMS shows an error message.
+
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 incidents without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Performance first for vehicle dispatch upon new incident creation.
.  Interface should prioritise user experience since operators function in a high stress environment.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[IMS]] IMS::
Incident Management System

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
